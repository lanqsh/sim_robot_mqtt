================================================================================
                        机器人MQTT模拟系统架构设计文档
================================================================================

文档版本：1.0
创建日期：2026年2月6日
项目名称：sim_robot_mqtt


================================================================================
第一章  项目概述
================================================================================

1.1 项目简介

    本项目是一个基于C++实现的机器人MQTT模拟系统，用于模拟多个机器人客户端
    通过MQTT协议与服务器进行通信。系统支持实时数据上报、远程控制、告警管理
    等功能，并提供完整的Web管理界面和REST API接口。

1.2 核心功能

    (1) MQTT通信：基于Eclipse Paho MQTT库实现异步消息收发
    (2) 多机器人管理：支持动态添加、删除和配置多个机器人实例
    (3) 数据上报：定时自动上报机器人状态和遥测数据
    (4) 远程控制：接收并处理来自服务器的控制命令
    (5) 告警管理：支持4类告警配置（FA/FB/FC/FD），每类包含多个告警位
    (6) Web界面：提供友好的浏览器管理界面
    (7) REST API：提供标准HTTP接口供第三方系统集成
    (8) 数据持久化：使用SQLite数据库存储配置和状态

1.3 应用场景

    (1) 机器人系统开发测试
    (2) MQTT通信协议验证
    (3) 大规模机器人集群模拟
    (4) 远程监控和控制系统原型
    (5) 物联网平台功能验证


================================================================================
第二章  系统架构
================================================================================

2.1 整体架构

    系统采用分层架构设计，主要分为以下几层：

    展示层（Presentation Layer）
        └── Web前端界面（HTML + CSS + JavaScript）
        └── HTTP REST API

    应用层（Application Layer）
        └── HTTP服务器（基于cpp-httplib）
        └── 业务逻辑处理模块
        └── 命令调度模块

    核心层（Core Layer）
        └── MQTT管理器（MqttManager）
        └── 机器人实例管理（Robot）
        └── 消息队列处理
        └── 线程管理

    数据层（Data Layer）
        └── 配置数据库（ConfigDb）
        └── SQLite数据库
        └── 内存缓存

2.2 组件关系图

    [Web浏览器]
         |
         | HTTP/REST API
         |
    [HttpServer] ←→ [ConfigDb]
         |              |
         | 方法调用      | 数据读写
         |              |
    [MqttManager] ←→ [SQLite数据库]
         |
         | 管理多个
         |
    [Robot实例1] [Robot实例2] ... [Robot实例N]
         |            |              |
         | MQTT通信   | MQTT通信     | MQTT通信
         |            |              |
    [MQTT Broker] ← → [MQTT Broker] ← → [MQTT Broker]

2.3 核心类设计

2.3.1 ConfigDb类

    职责：
        数据库操作的封装，提供配置读写、机器人管理、告警配置等功能

    主要方法：
        Initialize()                     - 初始化数据库和表结构
        GetMqttConfig()                  - 获取MQTT配置
        GetRobots()                      - 获取所有机器人列表
        AddRobot()                       - 添加新机器人
        RemoveRobot()                    - 删除机器人
        UpdateRobotStatus()              - 更新机器人启用状态
        UpdateRobotAlarms()              - 更新机器人告警配置
        GetRobotAlarms()                 - 获取机器人告警配置

    数据结构：
        MqttConfig                       - MQTT配置结构体
        RobotInfo                        - 机器人信息结构体
        AlarmData                        - 告警数据结构体

2.3.2 MqttManager类

    职责：
        管理所有机器人实例的MQTT连接，协调消息收发

    主要成员：
        mqtt_client_                     - MQTT客户端实例
        robots_map_                      - 机器人实例映射表
        config_db_                       - 数据库引用（shared_ptr）
        send_queue_                      - 发送消息队列
        receive_queue_                   - 接收消息队列
        robots_mutex_                    - 机器人映射表互斥锁
        send_queue_mutex_                - 发送队列互斥锁
        receive_queue_mutex_             - 接收队列互斥锁

    主要方法：
        Connect()                        - 连接MQTT Broker
        Disconnect()                     - 断开MQTT连接
        AddRobot()                       - 添加机器人实例
        RemoveRobot()                    - 移除机器人实例
        GetRobot()                       - 获取机器人实例
        SendLoop()                       - 消息发送循环（独立线程）
        ReceiveLoop()                    - 消息接收循环（独立线程）

    线程模型：
        主线程：管理机器人实例，处理HTTP请求
        发送线程：从发送队列取消息并发布到MQTT
        接收线程：从接收队列取消息并分发给机器人
        机器人线程（N个）：每个机器人独立线程定时上报

2.3.3 Robot类

    职责：
        单个机器人实例的业务逻辑，包括数据生成、消息处理、状态管理

    主要成员：
        robot_id_                        - 机器人唯一标识
        serial_number_                   - 机器人序号
        config_db_                       - 数据库引用（weak_ptr）
        mqtt_manager_                    - MQTT管理器引用（weak_ptr）
        data_                            - 机器人实时数据
        running_                         - 运行状态标志
        report_thread_                   - 数据上报线程

    主要方法：
        Start()                          - 启动机器人（开启上报线程）
        Stop()                           - 停止机器人
        HandleMessage()                  - 处理接收到的MQTT消息
        GenerateData()                   - 生成模拟数据
        GetData()                        - 获取当前数据
        SetConfigDb()                    - 设置数据库引用
        UpdateAlarmsToDb()               - 更新告警配置到数据库

    数据模型：
        battery_                         - 电池相关数据
        motor_                           - 电机相关数据
        photovoltaic_                    - 光伏数据
        system_                          - 系统状态
        alarms_                          - 告警配置（FA/FB/FC/FD）

2.3.4 HttpServer类

    职责：
        提供HTTP服务，处理Web界面访问和REST API请求

    主要成员：
        server_                          - httplib服务器实例
        mqtt_manager_                    - MQTT管理器引用
        config_db_                       - 数据库引用
        server_thread_                   - HTTP服务线程
        port_                            - 监听端口

    路由定义：
        GET  /                           - 返回Web界面首页
        GET  /api/robots                 - 获取所有机器人列表
        POST /api/robots                 - 添加新机器人
        DELETE /api/robots/:id           - 删除指定机器人
        PATCH /api/robots/:id/status     - 更新机器人状态
        GET  /api/robots/:id/data        - 获取机器人详细数据
        GET  /api/robots/:id/alarms      - 获取机器人告警配置
        PATCH /api/robots/:id/alarms     - 更新机器人告警配置
        POST /api/schedule               - 发送定时启动命令
        POST /api/start                  - 发送立即启动命令
        POST /api/timesync               - 发送校时命令

    CORS支持：
        所有API响应包含跨域头，支持前后端分离部署


================================================================================
第三章  技术栈
================================================================================

3.1 开发语言和标准

    语言：C++17
    编译器要求：GCC 7+ / Clang 5+ / MSVC 2017+
    构建工具：CMake 3.14+

3.2 第三方库

3.2.1 核心依赖库

    (1) Eclipse Paho MQTT C/C++库
        版本：1.3+
        用途：MQTT客户端实现
        功能：连接管理、消息发布/订阅、QoS控制
        安装：libpaho-mqtt-dev, libpaho-mqttpp-dev

    (2) SQLite3
        版本：3.x
        用途：配置和状态持久化
        功能：数据库创建、SQL查询、事务管理
        安装：libsqlite3-dev

    (3) cpp-httplib
        版本：0.11+
        用途：HTTP服务器实现
        功能：路由管理、请求处理、静态文件服务、CORS
        安装：libhttplib-dev 或 手动下载httplib.h

    (4) nlohmann/json
        版本：3.x
        用途：JSON数据解析和生成
        功能：对象序列化、数组操作、类型转换
        安装：nlohmann-json3-dev

    (5) Google glog
        版本：0.4+
        用途：日志记录
        功能：多级别日志、文件输出、线程安全
        安装：libgoogle-glog-dev

3.2.2 标准库使用

    (1) 线程库（std::thread）
        用于多线程并发处理

    (2) 互斥锁（std::mutex, std::lock_guard）
        用于线程同步和数据保护

    (3) 智能指针（std::shared_ptr, std::weak_ptr, std::unique_ptr）
        用于内存管理，避免内存泄漏

    (4) 队列容器（std::queue, std::deque）
        用于消息队列实现

    (5) 映射容器（std::map, std::unordered_map）
        用于机器人实例管理

3.3 前端技术栈

    (1) HTML5
        语义化标签、表单元素

    (2) CSS3
        Flexbox布局、Grid布局、动画、渐变

    (3) JavaScript ES6+
        模块化（import/export）、箭头函数、Promise、async/await

    (4) 无第三方框架
        纯原生JavaScript实现，无jQuery、React、Vue等依赖


================================================================================
第四章  数据库设计
================================================================================

4.1 数据库技术选型

    数据库类型：SQLite3（嵌入式关系型数据库）
    文件位置：config.db（可执行文件同目录）
    字符编码：UTF-8
    事务支持：是
    并发控制：文件锁

4.2 表结构设计

4.2.1 mqtt_config表（MQTT配置表）

    表说明：存储MQTT连接参数和系统配置

    表结构：
        列名                  类型        约束          说明
        -----------------------------------------------------------
        id                   INTEGER     PRIMARY KEY   自增主键
        key                  TEXT        NOT NULL      配置键名
        value                TEXT        NOT NULL      配置值

    配置项列表：
        broker               tcp://主机:端口          MQTT Broker地址
        client_id_prefix     字符串                   客户端ID前缀
        qos                  0/1/2                    消息质量等级
        keepalive            整数（秒）               心跳间隔
        publish_interval     整数（秒）               上报间隔
        http_port            整数                     HTTP服务端口
        publish_topic        字符串模板               发布主题（含{robot_id}占位符）
        subscribe_topic      字符串模板               订阅主题（含{robot_id}占位符）

    主题模板说明：
        {robot_id}会在运行时被替换为实际的机器人ID
        示例：application/xxx/device/{robot_id}/event/up

4.2.2 robots表（机器人信息表）

    表说明：存储所有机器人的配置和状态

    表结构：
        列名                  类型        约束          默认值      说明
        --------------------------------------------------------------------
        id                   INTEGER     PRIMARY KEY   自增        数据库主键
        robot_id             TEXT        NOT NULL      无          机器人唯一标识
        serial_number        INTEGER     NOT NULL      0           机器人序号
        robot_name           TEXT        NULL          NULL        机器人显示名称
        enabled              INTEGER     NOT NULL      1           启用状态（1启用/0禁用）
        alarm_fa             INTEGER     NOT NULL      0           FA类告警配置（位掩码）
        alarm_fb             INTEGER     NOT NULL      0           FB类告警配置（位掩码）
        alarm_fc             INTEGER     NOT NULL      0           FC类告警配置（位掩码）
        alarm_fd             INTEGER     NOT NULL      0           FD类告警配置（位掩码）

    索引：
        CREATE UNIQUE INDEX idx_robot_id ON robots(robot_id)
        CREATE UNIQUE INDEX idx_serial_number ON robots(serial_number)

    告警字段说明：
        alarm_fa：FA类告警，27位，设备状态和运行状态
        alarm_fb：FB类告警，11位，启动方式和重启原因
        alarm_fc：FC类告警，31位，硬件故障和传感器故障
        alarm_fd：FD类告警，5位，电流预警和温度预警

    告警位定义：
        每个告警字段使用位掩码（bit mask）存储
        每一位（bit）代表一个具体的告警项
        位值为1表示该告警启用，0表示禁用
        示例：alarm_fa = 7 = 0b111，表示前3位告警启用

4.3 数据初始化

    程序首次运行时自动执行：
        (1) 创建config.db数据库文件
        (2) 创建mqtt_config表并插入默认配置
        (3) 创建robots表
        (4) 可选：插入默认测试机器人数据

4.4 数据访问层

    ConfigDb类提供统一的数据访问接口：
        (1) 使用预编译语句（prepared statement）提高性能
        (2) 使用事务保证数据一致性
        (3) 异常安全，失败时自动回滚
        (4) 线程安全，使用互斥锁保护数据库操作


================================================================================
第五章  MQTT通信设计
================================================================================

5.1 MQTT协议版本

    使用版本：MQTT 3.1.1
    QoS级别：可配置（0/1/2），默认为1

5.2 连接管理

5.2.1 客户端标识

    Client ID格式：{client_id_prefix}_{robot_id}
    示例：sim_robot_cpp_303930306350729d

5.2.2 连接参数

    Clean Session：true（不保留会话状态）
    Keep Alive：60秒（可配置）
    自动重连：是
    连接超时：10秒

5.3 主题设计

5.3.1 主题结构

    上行主题（发布）：
        格式：application/{app_id}/device/{robot_id}/event/up
        用途：机器人向服务器上报数据
        QoS：1（至少一次）

    下行主题（订阅）：
        格式：application/{app_id}/device/{robot_id}/command/down
        用途：服务器向机器人发送控制命令
        QoS：1（至少一次）

5.3.2 主题通配符

    不使用通配符，每个机器人订阅自己的特定主题
    优点：
        安全性高，机器人只能接收发给自己的消息
        便于权限控制和审计
        避免消息混淆

5.4 消息格式

5.4.1 上行消息（遥测数据）

    格式：JSON
    示例：
    {
      "robot_id": "303930306350729d",
      "timestamp": 1707206400,
      "battery": {
        "voltage": 48.5,
        "current": 12.3,
        "soc": 85,
        "temperature": 28.5
      },
      "motor": {
        "master_current": 5.2,
        "slave_current": 5.1
      },
      "position": 120.5,
      "runtime": 3600,
      "run_count": 15,
      "cycles": 8,
      "photovoltaic": {
        "voltage": 36.0,
        "current": 2.5
      },
      "board_temp": 45.2,
      "alarms": {
        "fa": 134217727,
        "fb": 2047,
        "fc": 2147483647,
        "fd": 31
      }
    }

5.4.2 下行消息（控制命令）

    命令类型：

    (1) 定时启动命令
    {
      "command": "schedule",
      "schedule_id": 1,
      "weekday": 2,
      "hour": 8,
      "minute": 30,
      "run_count": 3
    }

    (2) 立即启动命令
    {
      "command": "start"
    }

    (3) 校时命令
    {
      "command": "timesync",
      "timestamp": 1707206400
    }

    (4) 停止命令
    {
      "command": "stop"
    }

    (5) 告警配置命令
    {
      "command": "set_alarms",
      "alarms": {
        "fa": 134217727,
        "fb": 2047,
        "fc": 2147483647,
        "fd": 31
      }
    }

5.5 消息队列机制

5.5.1 发送队列

    实现：std::queue<QueuedMessage>
    线程：独立发送线程处理
    流程：
        (1) Robot生成消息并加入发送队列
        (2) 发送线程从队列取消息
        (3) 调用MQTT客户端发布消息
        (4) 记录发送日志

5.5.2 接收队列

    实现：std::queue<ReceivedMessage>
    线程：独立接收线程处理
    流程：
        (1) MQTT回调函数接收消息，加入接收队列
        (2) 接收线程从队列取消息
        (3) 根据topic找到目标Robot
        (4) 调用Robot的HandleMessage处理
        (5) 记录处理日志

5.5.3 线程同步

    使用互斥锁保护队列访问：
        send_queue_mutex_：保护发送队列
        receive_queue_mutex_：保护接收队列

    使用条件变量实现高效等待：
        队列为空时线程等待
        有新消息时唤醒线程处理


================================================================================
第六章  HTTP服务设计
================================================================================

6.1 服务器架构

    实现库：cpp-httplib
    运行模式：独立线程运行，不阻塞主程序
    端口：可配置，默认8080
    协议：HTTP/1.1

6.2 静态文件服务

    Web根目录：./web
    支持文件类型：
        .html → text/html
        .css  → text/css
        .js   → application/javascript
        .json → application/json

    主页：
        URL：http://localhost:8080/
        文件：web/html/index.html

6.3 REST API设计

6.3.1 通用响应格式

    成功响应：
    {
      "success": true,
      "data": { ... }         // 可选，返回的数据
    }

    失败响应：
    {
      "success": false,
      "error": "错误描述信息"
    }

6.3.2 机器人管理API

    (1) 获取机器人列表
        请求：GET /api/robots
        参数：无
        响应：
        {
          "success": true,
          "robots": [
            {
              "robot_id": "303930306350729d",
              "serial_number": 1,
              "robot_name": "Robot 1",
              "enabled": 1
            },
            ...
          ]
        }

    (2) 添加机器人
        请求：POST /api/robots
        Content-Type: application/json
        请求体：
        {
          "robot_id": "303930306350729f",
          "robot_name": "New Robot",
          "serial_number": 3
        }
        响应：
        {
          "success": true,
          "robot_id": "303930306350729f"
        }

    (3) 删除机器人
        请求：DELETE /api/robots/{robot_id}
        参数：robot_id（路径参数）
        响应：
        {
          "success": true,
          "robot_id": "303930306350729f"
        }

    (4) 更新机器人状态
        请求：PATCH /api/robots/{robot_id}/status
        Content-Type: application/json
        请求体：
        {
          "enabled": 1    // 1启用，0禁用
        }
        响应：
        {
          "success": true,
          "robot_id": "303930306350729d",
          "enabled": 1
        }

    (5) 获取机器人详细数据
        请求：GET /api/robots/{robot_id}/data
        参数：robot_id（路径参数）
        响应：
        {
          "success": true,
          "robot_id": "303930306350729d",
          "data": {
            "battery": { ... },
            "motor": { ... },
            ...
          }
        }

6.3.3 告警管理API

    (1) 获取告警配置
        请求：GET /api/robots/{identifier}/alarms?type=id
        参数：
            identifier：机器人ID或序号
            type：查询类型（id或serial）
        响应：
        {
          "success": true,
          "robot_id": "303930306350729d",
          "alarm_fa": 134217727,
          "alarm_fb": 2047,
          "alarm_fc": 2147483647,
          "alarm_fd": 31
        }

    (2) 设置告警配置
        请求：PATCH /api/robots/{identifier}/alarms?type=id
        Content-Type: application/json
        请求体：
        {
          "alarm_fa": 134217727,
          "alarm_fb": 2047,
          "alarm_fc": 2147483647,
          "alarm_fd": 31
        }
        响应：
        {
          "success": true,
          "robot_id": "303930306350729d"
        }

6.3.4 命令发送API

    (1) 定时启动命令
        请求：POST /api/schedule
        Content-Type: application/json
        请求体：
        {
          "robot_id": "303930306350729d",
          "serial_number": "",
          "schedule_id": 1,
          "weekday": 2,
          "hour": 8,
          "minute": 30,
          "run_count": 3
        }

    (2) 立即启动命令
        请求：POST /api/start
        Content-Type: application/json
        请求体：
        {
          "robot_id": "303930306350729d",
          "serial_number": ""
        }

    (3) 校时命令
        请求：POST /api/timesync
        Content-Type: application/json
        请求体：
        {
          "robot_id": "303930306350729d",
          "serial_number": ""
        }

6.4 CORS配置

    所有API响应自动添加以下CORS头：
        Access-Control-Allow-Origin: *
        Access-Control-Allow-Methods: GET, POST, PATCH, DELETE, OPTIONS
        Access-Control-Allow-Headers: Content-Type

6.5 错误处理

    HTTP状态码使用：
        200 OK：请求成功
        400 Bad Request：请求参数错误
        404 Not Found：资源不存在
        500 Internal Server Error：服务器内部错误

    所有API错误都返回JSON格式，包含error字段说明错误原因


================================================================================
第七章  前端架构设计
================================================================================

7.1 目录结构

    web/
    ├── html/
    │   └── index.html          主HTML文件
    ├── css/
    │   ├── layout.css          布局样式
    │   └── components.css      组件样式
    └── js/
        ├── app.js              主入口和全局协调
        ├── config.js           配置常量
        ├── api.js              API调用封装
        ├── ui.js               UI渲染模块
        ├── pagination.js       分页管理
        ├── robot-operations.js 机器人操作
        └── commands.js         命令发送和告警管理

7.2 模块化设计

7.2.1 config.js（配置模块）

    职责：
        定义全局配置常量
        API基础URL
        字段映射表
        UI配置

    导出内容：
        API_BASE_URL：API基础地址
        FIELD_LABELS：字段中文名称映射
        WEEKDAY_NAMES：星期名称映射

7.2.2 api.js（API调用模块）

    职责：
        封装所有HTTP API调用
        统一错误处理
        请求响应格式化

    主要函数：
        fetchRobots(page, pageSize)
        addRobot(robotName, serialNumber)
        deleteRobot(robotId)
        updateRobotStatus(robotId, enabled)
        fetchRobotData(robotId)
        getRobotAlarms(identifier, type)
        setRobotAlarms(identifier, type, alarmData)
        sendScheduleStartRequest(...)
        sendStartRequest(...)
        sendTimeSyncRequest(...)
        batchAddRobots(robots)
        batchDeleteRobots(robotIds)

7.2.3 ui.js（UI渲染模块）

    职责：
        所有DOM操作
        组件渲染
        模态框管理
        加载状态显示

    主要函数：
        updateStatistics(statistics)
        renderRobots(robots)
        renderRobotData(data)
        renderAlarmSettings(alarmData)
        showEmptyState()
        showError(message)
        showLoading(text)
        hideLoading()
        closeModal()
        openAlarmModal()
        closeAlarmModal()
        toggleForm(contentId, iconId)

7.2.4 pagination.js（分页管理模块）

    职责：
        分页状态管理
        分页控件渲染
        页码跳转逻辑

    PaginationManager类：
        构造函数：接收loadCallback和容器ID
        updatePagination(pagination)
        renderPagination()
        goToPage(page)
        changePageSize(newPageSize)
        getCurrentPage()
        getPageSize()

7.2.5 robot-operations.js（机器人操作模块）

    职责：
        机器人CRUD操作
        批量操作
        状态切换

    主要函数：
        toggleRobotStatus(robotId, currentStatus)
        addRobot(robotName, serialNumber, callback)
        deleteRobot(robotId, callback)
        viewRobotData(robotId)
        batchAdd(robotsText, callback)
        batchDelete(robotIds, callback)

7.2.6 commands.js（命令和告警模块）

    职责：
        命令发送
        告警数据加载
        告警标签页切换

    主要函数：
        sendScheduleRequest(robotId, serialNumber, scheduleId, weekday, hour, minute, runCount)
        sendStartRequest(robotId, serialNumber)
        sendTimeSyncRequest(robotId, serialNumber)
        loadAlarmData()
        switchAlarmTab(type)

7.2.7 app.js（主入口模块）

    职责：
        协调所有模块
        初始化应用
        全局事件监听
        定时刷新任务
        暴露window全局函数

    暴露的全局函数：
        window.toggleScheduleForm()
        window.toggleStartForm()
        window.toggleTimeSyncForm()
        window.toggleAddRobotForm()
        window.toggleBatchForm()
        window.sendScheduleRequest()
        window.sendStartRequest()
        window.sendTimeSyncRequest()
        window.openAlarmSettings(robotId, serialNumber)
        window.saveAlarmSettings()
        window.closeAlarmModal()
        window.switchAlarmTab(type)
        （其他操作函数...）

7.3 页面布局

7.3.1 整体布局

    顶部区域：
        标题和统计信息

    控制面板区域（可折叠）：
        定时启动设置
        立即启动
        校时请求

    机器人列表区域：
        统计卡片（总数、启用数、禁用数）
        机器人卡片网格
        分页控件

7.3.2 机器人卡片

    每个卡片包含：
        序号和名称
        机器人ID
        状态指示器（启用/禁用）
        操作按钮：
            查看数据
            告警设置
            启用/禁用
            删除

7.3.3 模态框

    (1) 机器人数据模态框
        显示完整的机器人实时数据
        分组展示：电池、电机、光伏、系统

    (2) 告警设置模态框
        四个标签页：FA/FB/FC/FD
        每个标签页显示对应类型的所有告警项
        复选框选择启用的告警
        搜索框过滤告警项
        两列布局，最大高度500px，支持滚动

7.4 样式设计

7.4.1 layout.css（布局样式）

    全局重置
    容器布局
    网格系统
    响应式断点

7.4.2 components.css（组件样式）

    按钮样式
    表单元素
    卡片组件
    模态框
    折叠面板
    分页控件
    统计卡片
    告警设置界面

    设计原则：
        扁平化设计
        柔和渐变
        卡片阴影
        流畅动画
        响应式布局

7.5 交互设计

7.5.1 数据加载

    初始加载：
        显示加载动画
        异步获取机器人列表
        渲染卡片和统计信息

    自动刷新：
        每10秒自动刷新列表
        仅更新数据，不影响用户操作

7.5.2 表单折叠

    默认状态：折叠（节省空间）
    点击标题：展开/折叠切换
    图标：▼（折叠）/ ▲（展开）

7.5.3 模态框交互

    打开：点击按钮，显示遮罩和内容
    关闭：
        点击关闭按钮
        点击遮罩区域
        按ESC键（可选）

7.5.4 告警设置交互

    打开：
        自动从后端加载当前配置
        显示加载状态

    切换标签：
        自动加载对应类型的告警数据
        更新复选框状态

    搜索过滤：
        实时过滤告警列表
        不区分大小写

    保存：
        收集所有选中的告警位
        显示确认对话框
        发送PATCH请求
        提示保存结果


================================================================================
第八章  告警系统设计
================================================================================

8.1 告警分类

    系统支持4类告警，每类包含不同数量的告警位：

    FA类告警（27位）：设备状态和运行状态
        Bit 0：设备启用/停用
        Bit 1：启动队列切换中
        Bit 2：自动/手动
        Bit 3：启动失败
        Bit 4：自动运行中（指清扫中）
        Bit 5：自动运行完成（指清扫完成）
        Bit 6：自动运行失败
        Bit 7：前进
        Bit 8：后退
        Bit 9：运行停止
        Bit 10：近端触发
        Bit 11：远端触发
        Bit 12：急停状态
        Bit 13：自动复位中
        Bit 14：自动复位完成
        Bit 15：低电量返回停靠位成功
        Bit 16：上限停机返回成功
        Bit 17：白天防误扫触发
        Bit 18：白夜状态（光线传感器状态）
        Bit 19：运行结束（含正常异常停止）
        Bit 20：有无授权
        Bit 21：上限停机返回原位成功
        Bit 22：上限停机返回停机平台成功
        Bit 23：机身卡套
        Bit 24：机身卡套恢复
        Bit 25：平台不允许运行
        Bit 26：自动运行请求回复超时

    FB类告警（11位）：启动方式和重启原因
        Bit 0：遥控器启动
        Bit 1：app控制启动
        Bit 2：串口控制启动
        Bit 3：scada主动控制启动
        Bit 4：机器人定时启动
        Bit 5：机器人异常回退请求启动
        Bit 6：断电或者重启之后等致复启动
        Bit 7：长时间无法通信等致重启
        Bit 8：机器人本人入网等致重启
        Bit 9：升级成功导致重启
        Bit 10：命令重启

    FC类告警（31位）：硬件故障和传感器故障
        Bit 0：充放电控制器通信故障
        Bit 1：电池包通信故障
        Bit 2：SPI存储模块通信故障
        Bit 3：低手保护电量预警
        Bit 4：温湿度传感器通信故障
        Bit 5：电池电压保护
        Bit 6：电池温度保护（高温）
        Bit 7：电池电流保护
        Bit 8：低电量保护
        Bit 9：主电机上限故障（上限停机）
        Bit 10：从电机上限故障（上限停机）
        Bit 11：远近端无信号
        Bit 12：自动运行超时
        Bit 13：Lora通信故障（离线）
        Bit 14：大风保护
        Bit 15：湿度保护
        Bit 16：电池放电欠压
        Bit 17：电池放电温度故障
        Bit 18：电池放电过流
        Bit 19：电池放电短路
        Bit 20：电池充电过压
        Bit 21：电池充电过温
        Bit 22：电池超低压或者断线
        Bit 23：电池寿命到期
        Bit 24：角度传感器故障
        Bit 25：二次运行超时
        Bit 26：主末保护
        Bit 27：环境温度故障
        Bit 28：主板温度故障
        Bit 29：主电机瞬时电流过大故障
        Bit 30：从电机瞬时电流过大故障

    FD类告警（5位）：电流预警和温度预警
        Bit 0：主电机上限电流预警
        Bit 1：从电机上限电流预警
        Bit 2：电池高温预警
        Bit 3：电池低温预警
        Bit 4：设备掉电预警

8.2 存储方式

    数据库存储：
        每类告警使用一个INTEGER字段
        使用位掩码（bit mask）方式存储
        每一位代表一个告警项，1表示启用，0表示禁用

    内存存储：
        Robot类维护AlarmData结构体
        包含alarm_fa、alarm_fb、alarm_fc、alarm_fd四个字段
        程序启动时从数据库加载到内存

8.3 配置流程

    (1) 用户操作：
        点击机器人卡片的"告警设置"按钮

    (2) 前端加载：
        调用GET /api/robots/{id}/alarms
        从内存中读取当前告警配置

    (3) 渲染界面：
        显示4个标签页（FA/FB/FC/FD）
        根据位掩码值勾选对应的复选框

    (4) 用户修改：
        切换标签页查看不同类型告警
        使用搜索框过滤告警项
        勾选或取消勾选复选框

    (5) 保存配置：
        收集所有复选框状态
        计算4个位掩码值
        调用PATCH /api/robots/{id}/alarms

    (6) 后端处理：
        解析请求中的告警值
        更新Robot对象的内存数据
        调用robot->UpdateAlarmsToDb()持久化到数据库

    (7) 确认结果：
        返回成功/失败响应
        前端显示提示消息

8.4 技术实现细节

8.4.1 位操作

    设置位：value |= (1 << bit)
    清除位：value &= ~(1 << bit)
    检查位：(value & (1 << bit)) != 0

8.4.2 内存优化

    获取告警：直接从Robot对象读取，不访问数据库
    设置告警：先更新Robot对象，再调用UpdateAlarmsToDb()
    启动加载：程序启动时一次性加载所有机器人告警配置

8.4.3 数据一致性

    使用weak_ptr避免循环引用
    Robot持有ConfigDb的weak_ptr
    更新告警时检查ConfigDb是否有效
    事务保证数据库操作原子性


================================================================================
第九章  线程模型与并发控制
================================================================================

9.1 线程结构

    主线程：
        职责：程序初始化、用户交互、资源管理
        循环：事件循环，等待用户输入或信号

    HTTP服务线程：
        职责：监听HTTP请求，处理API调用
        启动：HttpServer::Start()
        阻塞：accept()等待连接

    MQTT发送线程：
        职责：从发送队列取消息并发布到MQTT Broker
        循环：无限循环，队列为空时等待
        同步：send_queue_mutex_

    MQTT接收线程：
        职责：从接收队列取消息并分发给Robot处理
        循环：无限循环，队列为空时等待
        同步：receive_queue_mutex_

    机器人上报线程（N个）：
        职责：定时生成数据并加入发送队列
        数量：每个Robot一个线程
        间隔：可配置，默认10秒

9.2 线程同步

9.2.1 互斥锁使用

    robots_mutex_：
        保护：robots_map_（机器人实例映射表）
        操作：添加、删除、查找机器人

    send_queue_mutex_：
        保护：send_queue_（发送消息队列）
        操作：入队、出队发送消息

    receive_queue_mutex_：
        保护：receive_queue_（接收消息队列）
        操作：入队、出队接收消息

9.2.2 锁的作用域

    使用RAII机制：std::lock_guard自动管理锁
    原则：锁的持有时间尽可能短
    避免：嵌套锁、死锁

9.3 线程安全设计

9.3.1 数据保护策略

    共享数据必须使用互斥锁保护
    读写操作都需要加锁
    避免在锁内进行耗时操作

9.3.2 智能指针的线程安全

    shared_ptr引用计数是线程安全的
    但指向的对象本身需要额外保护
    weak_ptr避免循环引用

9.3.3 消息队列的线程安全

    生产者-消费者模式
    使用std::queue作为缓冲
    互斥锁保证入队出队的原子性

9.4 性能优化

9.4.1 减少锁竞争

    细粒度锁：不同资源使用不同的锁
    读写分离：考虑使用读写锁（如果需要）
    无锁数据结构：可以考虑使用原子操作

9.4.2 异步处理

    HTTP请求异步处理，不阻塞主线程
    MQTT消息通过队列异步发送
    数据上报在独立线程中进行

9.4.3 资源复用

    MQTT客户端连接复用
    数据库连接复用（SQLite单连接）
    内存对象池（如果需要）


================================================================================
第十章  日志系统
================================================================================

10.1 日志库

    使用库：Google glog
    版本：0.4+
    特性：多级别、线程安全、文件输出

10.2 日志级别

    INFO（信息）：
        用途：正常操作记录
        示例：连接成功、消息发送、API调用

    WARNING（警告）：
        用途：潜在问题，不影响功能
        示例：配置缺失使用默认值、重试操作

    ERROR（错误）：
        用途：错误情况，影响部分功能
        示例：连接失败、数据库错误、API失败

    FATAL（致命）：
        用途：严重错误，程序无法继续
        示例：数据库初始化失败、必需配置缺失

10.3 日志输出

10.3.1 输出目标

    控制台：所有级别的日志
    文件：保存在./logs目录
        INFO日志：robot.INFO
        WARNING日志：robot.WARNING
        ERROR日志：robot.ERROR

10.3.2 日志格式

    格式：[级别][时间][文件:行号] 消息内容
    示例：I0206 10:30:45.123456 main.cpp:150] MQTT客户端已连接

10.4 日志内容

10.4.1 启动日志

    程序版本信息
    配置参数（Broker地址、端口、QoS等）
    启用的机器人列表
    主题模板

10.4.2 运行日志

    MQTT连接状态变化
    消息发送记录（主题、内容）
    消息接收记录（主题、内容）
    机器人启动/停止
    HTTP API调用（端点、参数、结果）
    数据库操作（增删改查）

10.4.3 错误日志

    连接失败原因
    消息发送失败
    数据库错误
    解析错误
    异常捕获


================================================================================
第十一章  部署指南
================================================================================

11.1 编译环境准备

11.1.1 Ubuntu/Debian系统

    安装依赖：
        sudo apt update
        sudo apt install -y build-essential cmake git
        sudo apt install -y libpaho-mqtt-dev libpaho-mqttpp-dev
        sudo apt install -y libsqlite3-dev nlohmann-json3-dev
        sudo apt install -y libgoogle-glog-dev libhttplib-dev

11.1.2 Windows系统

    使用vcpkg安装依赖：
        vcpkg install paho-mqttpp3:x64-windows
        vcpkg install sqlite3:x64-windows
        vcpkg install nlohmann-json:x64-windows
        vcpkg install glog:x64-windows
        vcpkg install cpp-httplib:x64-windows

11.1.3 macOS系统

    使用Homebrew安装依赖：
        brew install cmake
        brew install paho-mqtt-cpp
        brew install sqlite3
        brew install nlohmann-json
        brew install glog
        brew install cpp-httplib

11.2 编译步骤

    创建构建目录：
        mkdir -p build
        cd build

    配置项目：
        cmake ..

    编译：
        make -j$(nproc)        # Linux/macOS
        msbuild robot.sln      # Windows

    编译产物：
        可执行文件：build/robot（Linux/macOS）或 build/Release/robot.exe（Windows）

11.3 目录结构

    部署时需要的文件和目录：
        robot                   可执行文件
        config.db               数据库文件（首次运行自动创建）
        web/                    Web前端文件夹
        ├── html/
        │   └── index.html
        ├── css/
        │   ├── layout.css
        │   └── components.css
        └── js/
            ├── app.js
            ├── config.js
            ├── api.js
            ├── ui.js
            ├── pagination.js
            ├── robot-operations.js
            └── commands.js
        logs/                   日志目录（自动创建）

11.4 配置修改

11.4.1 修改MQTT Broker地址

    方法1：修改数据库
        sqlite3 config.db
        UPDATE mqtt_config SET value = 'tcp://your-broker:1883' WHERE key = 'broker';
        .quit

    方法2：删除数据库重新生成
        rm config.db
        编辑src/config_db.cpp中的默认值
        重新编译运行

11.4.2 修改HTTP端口

    修改数据库：
        sqlite3 config.db
        UPDATE mqtt_config SET value = '9090' WHERE key = 'http_port';
        .quit

11.4.3 修改上报间隔

    修改数据库：
        sqlite3 config.db
        UPDATE mqtt_config SET value = '30' WHERE key = 'publish_interval';
        .quit

11.5 运行方式

11.5.1 前台运行

    Linux/macOS：
        ./robot

    Windows：
        robot.exe

    查看日志：
        日志会同时输出到控制台和logs目录

11.5.2 后台运行（Linux）

    使用nohup：
        nohup ./robot > output.log 2>&1 &

    使用screen：
        screen -S robot
        ./robot
        按Ctrl+A, D分离会话

    使用systemd服务：
        创建/etc/systemd/system/robot.service
        [Unit]
        Description=Robot MQTT Simulator
        After=network.target

        [Service]
        Type=simple
        User=youruser
        WorkingDirectory=/path/to/robot
        ExecStart=/path/to/robot/robot
        Restart=always

        [Install]
        WantedBy=multi-user.target

        启动服务：
            sudo systemctl start robot
            sudo systemctl enable robot

11.6 监控和维护

11.6.1 查看日志

    实时查看：
        tail -f logs/robot.INFO

    搜索错误：
        grep ERROR logs/robot.INFO

11.6.2 数据库维护

    备份数据库：
        cp config.db config.db.backup

    查看数据库大小：
        ls -lh config.db

    优化数据库：
        sqlite3 config.db "VACUUM;"

11.6.3 性能监控

    CPU和内存使用：
        top -p $(pidof robot)

    网络连接：
        netstat -anp | grep robot

    线程数量：
        ps -eLf | grep robot | wc -l


================================================================================
第十二章  测试指南
================================================================================

12.1 单元测试

    建议使用Google Test框架
    测试覆盖：
        ConfigDb类的数据库操作
        Robot类的数据生成
        消息格式化和解析
        告警位操作

12.2 集成测试

12.2.1 MQTT通信测试

    使用mosquitto_sub订阅上行主题：
        mosquitto_sub -h broker-address -t "application/+/device/+/event/up" -v

    使用mosquitto_pub发送下行消息：
        mosquitto_pub -h broker-address -t "application/xxx/device/robot_id/command/down" -m '{"command":"start"}'

12.2.2 HTTP API测试

    使用curl测试：
        curl http://localhost:8080/api/robots
        curl -X POST http://localhost:8080/api/robots -H "Content-Type: application/json" -d '{"robot_id":"test","robot_name":"Test"}'
        curl -X DELETE http://localhost:8080/api/robots/test

    使用Postman测试：
        创建Collection包含所有API端点
        编写测试脚本验证响应

12.2.3 Web界面测试

    浏览器兼容性测试：
        Chrome、Firefox、Safari、Edge
        检查布局、交互、API调用

    功能测试：
        添加机器人
        查看数据
        配置告警
        发送命令
        删除机器人

12.3 压力测试

12.3.1 多机器人测试

    添加大量机器人（100+）
    观察：
        内存使用
        CPU使用
        消息发送延迟
        数据库响应时间

12.3.2 并发API测试

    使用Apache Bench：
        ab -n 1000 -c 10 http://localhost:8080/api/robots

    使用wrk：
        wrk -t4 -c100 -d10s http://localhost:8080/api/robots

12.4 长时间稳定性测试

    运行24小时以上
    监控：
        内存泄漏
        连接稳定性
        日志错误
        数据一致性


================================================================================
第十三章  故障排查
================================================================================

13.1 常见问题

13.1.1 编译错误

    问题：找不到httplib.h
    解决：
        下载httplib.h到third_party目录
        或安装libhttplib-dev包

    问题：找不到PahoMqttCpp
    解决：
        安装libpaho-mqttpp-dev
        检查CMakeLists.txt中的库路径

13.1.2 运行时错误

    问题：端口8080被占用
    解决：
        修改数据库中的http_port配置
        或杀死占用端口的进程

    问题：无法连接MQTT Broker
    解决：
        检查Broker地址是否正确
        检查网络连接
        检查防火墙设置
        使用公共测试Broker验证

    问题：Web界面显示404
    解决：
        确保web目录在可执行文件同目录
        检查文件权限
        查看HTTP服务器日志

13.2 日志分析

    连接问题：
        grep "连接失败" logs/robot.ERROR

    消息发送问题：
        grep "发送失败" logs/robot.ERROR

    数据库问题：
        grep "database" logs/robot.ERROR

13.3 调试技巧

13.3.1 启用详细日志

    修改代码中的日志级别：
        google::SetStderrLogging(google::INFO)

13.3.2 使用调试器

    GDB（Linux）：
        gdb ./robot
        run
        bt（查看堆栈）

    Visual Studio（Windows）：
        F5启动调试
        设置断点
        查看变量


================================================================================
第十四章  扩展开发
================================================================================

14.1 添加新的API端点

    步骤：
        (1) 在HttpServer类中添加路由
        (2) 实现处理函数
        (3) 更新API文档
        (4) 添加前端调用代码

    示例（添加获取统计信息API）：
        后端（src/http_server.cpp）：
            server_.Get("/api/statistics", [this](const httplib::Request& req, httplib::Response& res) {
                // 实现逻辑
            });

        前端（web/js/api.js）：
            export async function fetchStatistics() {
                const response = await fetch(`${API_BASE_URL}/api/statistics`);
                return await response.json();
            }

14.2 添加新的机器人数据字段

    步骤：
        (1) 在Robot类中添加成员变量
        (2) 在GenerateData()中生成数据
        (3) 在GetData()中返回JSON
        (4) 更新前端显示逻辑

14.3 实现WebSocket实时推送

    建议：
        使用websocketpp库
        在HttpServer中添加WebSocket端点
        机器人数据更新时推送到所有连接的客户端
        前端使用WebSocket接收实时数据

14.4 添加用户认证

    建议：
        使用JWT（JSON Web Token）
        添加users表存储用户信息
        API请求需要携带token
        前端登录后保存token

14.5 数据可视化

    建议：
        集成Chart.js或ECharts
        添加历史数据存储
        实现趋势图表展示


================================================================================
第十五章  最佳实践与设计模式
================================================================================

15.1 设计模式应用

15.1.1 单例模式

    应用：ConfigDb实例
    优点：全局唯一，避免重复初始化

15.1.2 观察者模式

    应用：MQTT消息订阅机制
    优点：解耦发送者和接收者

15.1.3 生产者-消费者模式

    应用：消息队列处理
    优点：异步处理，提高性能

15.1.4 工厂模式

    应用：Robot实例创建
    优点：统一创建逻辑，便于扩展

15.2 编码规范

15.2.1 命名规范

    类名：大写开头驼峰，如ConfigDb、MqttManager
    函数名：小写开头驼峰，如Connect()、AddRobot()
    成员变量：小写下划线，以下划线结尾，如robot_id_、mqtt_client_
    常量：全大写下划线，如MAX_RETRY_COUNT

15.2.2 注释规范

    类注释：说明类的职责和用途
    函数注释：说明参数、返回值、异常
    复杂逻辑：添加行内注释说明

15.2.3 错误处理

    使用异常处理机制
    记录详细的错误信息
    不忽略任何错误
    提供有意义的错误消息

15.3 性能优化建议

    避免不必要的拷贝，使用引用传参
    使用智能指针自动管理内存
    合理使用缓存减少数据库访问
    异步处理耗时操作
    使用对象池复用对象


================================================================================
第十六章  安全考虑
================================================================================

16.1 MQTT安全

    建议：
        使用TLS加密连接（mqtts://）
        启用用户名密码认证
        使用客户端证书
        限制主题访问权限

16.2 HTTP安全

    建议：
        使用HTTPS（需要SSL证书）
        添加API认证机制
        限制API访问频率
        输入验证防止注入攻击

16.3 数据安全

    建议：
        定期备份数据库
        敏感数据加密存储
        限制文件系统访问权限
        日志脱敏，不记录敏感信息


================================================================================
第十七章  版本历史与路线图
================================================================================

17.1 当前版本

    版本：1.0.0
    发布日期：2026年2月6日

    主要功能：
        多机器人MQTT通信
        Web管理界面
        REST API
        告警管理系统
        数据持久化

17.2 未来规划

    v1.1.0计划：
        WebSocket实时数据推送
        用户认证和权限管理
        数据可视化图表

    v1.2.0计划：
        批量操作增强
        数据导出功能
        操作日志记录

    v2.0.0计划：
        分布式部署支持
        高可用架构
        性能监控面板


================================================================================
附录A  配置文件参考
================================================================================

A.1 mqtt_config表配置项

    broker               MQTT Broker地址，格式：tcp://host:port
    client_id_prefix     客户端ID前缀，默认：sim_robot_cpp
    qos                  消息质量等级，可选值：0, 1, 2
    keepalive            心跳间隔（秒），推荐：60
    publish_interval     上报间隔（秒），推荐：10
    http_port            HTTP服务端口，默认：8080
    publish_topic        发布主题模板，包含{robot_id}占位符
    subscribe_topic      订阅主题模板，包含{robot_id}占位符

A.2 主题模板示例

    上行主题：
        application/your_app_id/device/{robot_id}/event/up

    下行主题：
        application/your_app_id/device/{robot_id}/command/down


================================================================================
附录B  API完整参考
================================================================================

B.1 机器人管理API

    GET /api/robots
        获取机器人列表
        响应：{"success":true,"robots":[...]}

    POST /api/robots
        添加机器人
        请求：{"robot_id":"...","robot_name":"...","serial_number":1}
        响应：{"success":true,"robot_id":"..."}

    DELETE /api/robots/{id}
        删除机器人
        响应：{"success":true,"robot_id":"..."}

    PATCH /api/robots/{id}/status
        更新状态
        请求：{"enabled":1}
        响应：{"success":true,"robot_id":"...","enabled":1}

    GET /api/robots/{id}/data
        获取详细数据
        响应：{"success":true,"robot_id":"...","data":{...}}

B.2 告警管理API

    GET /api/robots/{id}/alarms?type=id
        获取告警配置
        响应：{"success":true,"robot_id":"...","alarm_fa":0,...}

    PATCH /api/robots/{id}/alarms?type=id
        设置告警配置
        请求：{"alarm_fa":134217727,"alarm_fb":2047,...}
        响应：{"success":true,"robot_id":"..."}

B.3 命令发送API

    POST /api/schedule
        定时启动命令
        请求：{"robot_id":"...","schedule_id":1,...}

    POST /api/start
        立即启动命令
        请求：{"robot_id":"..."}

    POST /api/timesync
        校时命令
        请求：{"robot_id":"..."}


================================================================================
附录C  数据结构参考
================================================================================

C.1 MqttConfig结构体

    struct MqttConfig {
        std::string broker;
        std::string client_id_prefix;
        int qos;
        int keepalive;
        int publish_interval;
        int http_port;
        std::string publish_topic;
        std::string subscribe_topic;
    };

C.2 RobotInfo结构体

    struct RobotInfo {
        std::string robot_id;
        int serial_number;
        std::string robot_name;
        bool enabled;
    };

C.3 AlarmData结构体

    struct AlarmData {
        int alarm_fa;
        int alarm_fb;
        int alarm_fc;
        int alarm_fd;
    };


================================================================================
文档结束
================================================================================
